<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HSO - 医院空间句法优化器 Pro</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet">
    <script>
        tailwind.config = {
            theme: {
                extend: {
                    colors: {
                        primary: '#3b82f6',
                        secondary: '#64748b',
                        success: '#10b981',
                        warning: '#f59e0b',
                        danger: '#ef4444',
                    },
                    fontFamily: {
                        sans: ['Inter', 'system-ui', 'sans-serif']
                    }
                }
            }
        }
    </script>
    <style type="text/tailwindcss">
        @layer utilities {
            .scrollbar-hide::-webkit-scrollbar { display: none; }
            .scrollbar-hide { -ms-overflow-style: none; scrollbar-width: none; }
        }
    </style>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');
        
        body { font-family: 'Inter', sans-serif; overflow: hidden; user-select: none; }
        
        .canvas-container { position: relative; overflow: hidden; background-color: #f3f4f6; }
        
        /* 针对不同模式改变鼠标样式 */
        .cursor-pan { cursor: grab; }
        .cursor-panning { cursor: grabbing; }
        .cursor-draw { cursor: crosshair; }
        .cursor-select { cursor: default; }
        .cursor-move { cursor: move; }
        
        .tooltip {
            position: fixed;
            background: rgba(15, 23, 42, 0.9);
            color: white;
            font-size: 12px;
            padding: 8px 12px;
            border-radius: 6px;
            pointer-events: none;
            z-index: 50;
            backdrop-filter: blur(4px);
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255,255,255,0.1);
            transform: translate(15px, 15px);
        }
        
        /* 真正的光谱渐变 */
        .bg-gradient-spectrum {
            background: linear-gradient(to right, 
                hsl(240, 100%, 50%), /* Deep Blue */
                hsl(200, 100%, 50%), /* Light Blue */
                hsl(120, 100%, 50%), /* Green */
                hsl(60, 100%, 50%),  /* Yellow */
                hsl(30, 100%, 50%),  /* Orange */
                hsl(0, 100%, 50%)    /* Red */
            );
        }
    </style>
</head>
<body class="bg-gray-50 text-slate-800 h-screen flex overflow-hidden">
    <!-- Sidebar Tools -->
    <div class="w-64 bg-white border-r border-gray-200 flex flex-col shadow-sm z-10 shrink-0">
        <div class="p-4 border-b border-gray-100">
            <h1 class="text-xl font-bold text-slate-800 flex items-center gap-2">
                <i class="fa fa-line-chart text-blue-600"></i>
                HSO Pro
            </h1>
            <p class="text-xs text-slate-500 mt-1">Hospital Syntax Optimizer</p>
        </div>

        <div class="p-4 space-y-4 flex-1 overflow-y-auto scrollbar-hide">
            <!-- Instructions -->
            <div class="bg-blue-50 p-3 rounded-lg text-xs text-blue-800 leading-relaxed border border-blue-100">
                <p><strong>操作指南:</strong></p>
                <ul class="list-disc pl-3 mt-1 space-y-1 text-blue-700/80">
                    <li><strong>中键/空格+左键</strong>: 平移画布</li>
                    <li><strong>滚轮</strong>: 缩放视图</li>
                    <li><strong>左键</strong>: 点选 / 框选</li>
                    <li><strong>拖拽</strong>: 移动轴线 / 编辑端点</li>
                    <li><strong>Delete</strong>: 删除选中</li>
                    <li><strong>Ctrl+Z</strong>: 撤销</li>
                </ul>
            </div>

            <div class="space-y-2">
                <label class="text-xs font-semibold text-slate-400 uppercase">1. 底图导入</label>
                <div class="relative group">
                    <button id="uploadBtn" class="w-full flex items-center justify-center gap-2 py-2 px-4 border-2 border-dashed border-gray-300 rounded-lg text-sm text-gray-500 hover:border-blue-500 hover:text-blue-500 transition-colors">
                        <i class="fa fa-upload"></i>
                        上传 DXF/图片
                    </button>
                    <input type="file" id="fileInput" accept="image/*" onchange="handleFileUpload(event)" class="absolute inset-0 opacity-0 cursor-pointer">
                </div>
            </div>

            <div class="space-y-2">
                <label class="text-xs font-semibold text-slate-400 uppercase">2. 工具模式</label>
                <div class="flex gap-2">
                    <button id="selectBtn" onclick="setMode('SELECT')" class="flex-1 flex flex-col items-center gap-1 p-2 rounded-lg text-xs transition-all bg-gray-100 hover:bg-gray-200" title="选择/编辑 (V)">
                        <i class="fa fa-mouse-pointer text-base"></i>
                        选择 (V)
                    </button>
                    <button id="drawBtn" onclick="setMode('DRAW')" class="flex-1 flex flex-col items-center gap-1 p-2 rounded-lg text-xs transition-all hover:bg-gray-100" title="绘制轴线 (P)">
                        <i class="fa fa-pencil text-base"></i>
                        绘制 (P)
                    </button>
                </div>
            </div>

            <div class="space-y-2">
                <label class="text-xs font-semibold text-slate-400 uppercase">3. 功能标记 (POI)</label>
                <div class="grid grid-cols-2 gap-2">
                    <button id="emergencyBtn" onclick="setMode('POI_EMERGENCY')" class="poi-btn flex flex-col items-center justify-center p-2 rounded border text-xs border-gray-100 hover:bg-gray-50">
                        <div class="w-3 h-3 rounded-full bg-red-500 mb-1 shadow-sm"></div>
                        急诊入口
                    </button>
                    <button id="surgeryBtn" onclick="setMode('POI_SURGERY')" class="poi-btn flex flex-col items-center justify-center p-2 rounded border text-xs border-gray-100 hover:bg-gray-50">
                        <div class="w-3 h-3 rounded-full bg-blue-500 mb-1 shadow-sm"></div>
                        手术部
                    </button>
                    <button id="icuBtn" onclick="setMode('POI_ICU')" class="poi-btn flex flex-col items-center justify-center p-2 rounded border text-xs border-gray-100 hover:bg-gray-50">
                        <div class="w-3 h-3 rounded-full bg-purple-500 mb-1 shadow-sm"></div>
                        ICU
                    </button>
                    <button id="wardBtn" onclick="setMode('POI_WARD')" class="poi-btn flex flex-col items-center justify-center p-2 rounded border text-xs border-gray-100 hover:bg-gray-50">
                        <div class="w-3 h-3 rounded-full bg-emerald-500 mb-1 shadow-sm"></div>
                        护士站
                    </button>
                </div>
            </div>
            
            <div class="pt-4 border-t border-gray-100">
                <div class="text-xs text-gray-400 mb-2">整合度图例 (R=n)</div>
                <div class="flex items-center gap-2 mb-1">
                    <div class="w-full h-3 rounded bg-gradient-spectrum shadow-inner border border-gray-200"></div>
                </div>
                <div class="flex justify-between text-[10px] text-gray-400">
                    <span>Low (Blue)</span>
                    <span>High (Red)</span>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <div class="flex-1 flex flex-col relative overflow-hidden">
        <!-- Overlay Stats -->
        <div class="absolute top-4 left-4 z-10 pointer-events-none flex gap-2">
            <div class="bg-white/90 backdrop-blur shadow-sm rounded-lg p-2 px-3 border border-gray-200 flex flex-col pointer-events-auto">
                <span class="text-xs text-gray-500 uppercase font-semibold">Scale</span>
                <span id="zoomLevel" class="text-sm font-mono font-bold text-slate-700">100%</span>
            </div>
             <div class="bg-white/90 backdrop-blur shadow-sm rounded-lg p-2 px-3 border border-gray-200 flex flex-col pointer-events-auto">
                <span class="text-xs text-gray-500 uppercase font-semibold">Objects</span>
                <span id="objCount" class="text-sm font-mono font-bold text-slate-700">0 Lines</span>
            </div>
        </div>

        <div class="absolute top-4 right-4 z-10 flex gap-2 pointer-events-none">
             <button onclick="actions.undo()" class="pointer-events-auto bg-white hover:bg-gray-50 text-slate-700 p-2 rounded-lg shadow-sm border border-gray-200 transition-colors" title="撤销 (Ctrl+Z)">
                <i class="fa fa-undo"></i>
            </button>
            <button onclick="actions.deleteSelection()" class="pointer-events-auto bg-white hover:bg-red-50 text-red-600 p-2 rounded-lg shadow-sm border border-gray-200 transition-colors" title="删除选中 (Del)">
                <i class="fa fa-trash"></i>
            </button>
        </div>

        <!-- Canvas Area -->
        <div class="flex-1 bg-gray-100 relative canvas-container" id="canvasContainer">
            <canvas id="mainCanvas" class="block outline-none w-full h-full"></canvas>
            
            <!-- Tooltip -->
            <div id="tooltip" class="tooltip hidden">
                <div class="font-bold mb-1 border-b border-gray-600 pb-1 text-gray-300 flex justify-between items-center gap-4">
                    <span>ID: <span id="tooltipId" class="text-white"></span></span>
                </div>
                <div class="mt-1 flex justify-between gap-4"><span>Global (R=n):</span> <span id="tooltipGlobal" class="text-yellow-400 font-mono font-bold"></span></div>
                <div class="flex justify-between gap-4"><span>Local (R=3):</span> <span id="tooltipLocal" class="text-green-400 font-mono font-bold"></span></div>
            </div>
        </div>

        <!-- Bottom Diagnosis Panel -->
        <div class="h-48 bg-white border-t border-gray-200 flex shadow-[0_-4px_6px_-1px_rgba(0,0,0,0.05)] z-20 shrink-0">
            <!-- Card 1 -->
            <div class="flex-1 p-5 border-r border-gray-100 flex flex-col">
                <div class="flex items-center gap-2 mb-3">
                    <i class="fa fa-heartbeat text-rose-500 text-lg"></i>
                    <h3 class="font-bold text-slate-800">急救效率</h3>
                </div>
                <div class="flex-1 flex flex-col justify-center">
                    <div class="flex items-baseline gap-2">
                        <span id="emergencyDepth" class="text-3xl font-mono font-bold text-slate-800">-</span>
                        <span class="text-sm text-gray-500">Steps</span>
                    </div>
                    <div id="emergencyStatus" class="mt-2 text-xs font-medium px-2 py-1 rounded w-fit bg-gray-100 text-gray-500">
                        等待标记...
                    </div>
                </div>
            </div>

            <!-- Card 2 -->
            <div class="flex-1 p-5 border-r border-gray-100 flex flex-col">
                <div class="flex items-center gap-2 mb-3">
                    <i class="fa fa-lock text-amber-500 text-lg"></i>
                    <h3 class="font-bold text-slate-800">ICU 隐私</h3>
                </div>
                 <div class="flex-1 flex flex-col justify-center">
                    <div class="flex items-baseline gap-2">
                        <span id="privacyValue" class="text-3xl font-mono font-bold text-slate-800">0.00</span>
                        <span class="text-sm text-gray-500">R=3 Integration</span>
                    </div>
                    <p id="privacyMsg" class="text-xs text-gray-500 mt-2">等待标记...</p>
                </div>
            </div>

            <!-- Card 3 -->
            <div class="flex-1 p-5 flex flex-col">
                <div class="flex items-center gap-2 mb-3">
                    <i class="fa fa-connectdevelop text-blue-500 text-lg"></i>
                    <h3 class="font-bold text-slate-800">空间协同</h3>
                </div>
                <div class="flex-1">
                    <div class="text-sm text-gray-600 mb-4">
                        <div class="flex justify-between mb-1">
                            <span class="text-xs text-gray-400">主轴状态</span>
                            <span id="mainStreetStatus" class="text-xs font-bold text-gray-400">未检测</span>
                        </div>
                        <div class="flex justify-between">
                            <span class="text-xs text-gray-400">高活轴线</span>
                            <span id="highIntCount" class="text-xs font-mono font-bold">0</span>
                        </div>
                    </div>
                    <div class="w-full bg-gray-100 h-1.5 rounded-full overflow-hidden">
                        <div id="synergyBar" class="bg-blue-500 h-full transition-all duration-500 ease-out" style="width: 0%"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // --- 核心算法 (Space Syntax) ---
        const SyntaxEngine = {
            getIntersection: (l1, l2) => {
                const det = (l1.x2 - l1.x1) * (l2.y2 - l2.y1) - (l2.x2 - l2.x1) * (l1.y2 - l1.y1);
                if (det === 0) return null;
                const lambda = ((l2.y2 - l2.y1) * (l2.x2 - l1.x1) + (l2.x1 - l2.x2) * (l2.y2 - l1.y1)) / det;
                const gamma = ((l1.y1 - l1.y2) * (l2.x2 - l1.x1) + (l1.x2 - l1.x1) * (l2.y2 - l1.y1)) / det;
                return (0 < lambda && lambda < 1) && (0 < gamma && gamma < 1);
            },

            buildGraph: (lines) => {
                const adjList = new Map();
                lines.forEach(l => adjList.set(l.id, []));
                for (let i = 0; i < lines.length; i++) {
                    for (let j = i + 1; j < lines.length; j++) {
                        if (SyntaxEngine.getIntersection(lines[i], lines[j])) {
                            adjList.get(lines[i].id).push(lines[j].id);
                            adjList.get(lines[j].id).push(lines[i].id);
                        }
                    }
                }
                return adjList;
            },

            bfs: (startId, adjList, maxDepth = null) => {
                const distances = new Map();
                const queue = [{ id: startId, dist: 0 }];
                distances.set(startId, 0);
                let totalDepth = 0, nodeCount = 0;
                while (queue.length > 0) {
                    const { id, dist } = queue.shift();
                    totalDepth += dist;
                    nodeCount++;
                    if (maxDepth !== null && dist >= maxDepth) continue;
                    const neighbors = adjList.get(id) || [];
                    for (const neighbor of neighbors) {
                        if (!distances.has(neighbor)) {
                            distances.set(neighbor, dist + 1);
                            queue.push({ id: neighbor, dist: dist + 1 });
                        }
                    }
                }
                return { distances, totalDepth, nodeCount };
            },

            calculate: (lines) => {
                const adjList = SyntaxEngine.buildGraph(lines);
                const results = {};
                
                // 计算原始 Integration 值
                lines.forEach(line => {
                    const global = SyntaxEngine.bfs(line.id, adjList, null);
                    const local = SyntaxEngine.bfs(line.id, adjList, 3);
                    
                    const mdG = global.nodeCount > 1 ? global.totalDepth / (global.nodeCount - 1) : 0;
                    const mdL = local.nodeCount > 1 ? local.totalDepth / (local.nodeCount - 1) : 0;
                    
                    results[line.id] = {
                        globalRaw: mdG > 0 ? 1/mdG : 0,
                        localRaw: mdL > 0 ? 1/mdL : 0,
                        depths: global.distances
                    };
                });

                // 归一化 (0.0 - 1.0)
                let maxG = 0, minG = Infinity;
                Object.values(results).forEach(r => {
                    if (r.globalRaw > maxG) maxG = r.globalRaw;
                    if (r.globalRaw < minG) minG = r.globalRaw;
                });

                const range = maxG - minG;
                lines.forEach(line => {
                    const r = results[line.id];
                    r.global = r.globalRaw; // Display raw or processed? Let's use raw for value
                    r.local = r.localRaw;
                    // Normalized for Color (0=Blue, 1=Red)
                    r.norm = range === 0 ? 0.5 : (r.globalRaw - minG) / range;
                });
                
                return results;
            },

            distPointToSegment: (p, s) => {
                const A = p.x - s.x1, B = p.y - s.y1;
                const C = s.x2 - s.x1, D = s.y2 - s.y1;
                const dot = A * C + B * D;
                const len_sq = C * C + D * D;
                let param = -1;
                if (len_sq !== 0) param = dot / len_sq;
                let xx, yy;
                if (param < 0) { xx = s.x1; yy = s.y1; }
                else if (param > 1) { xx = s.x2; yy = s.y2; }
                else { xx = s.x1 + param * C; yy = s.y1 + param * D; }
                const dx = p.x - xx, dy = p.y - yy;
                return Math.sqrt(dx * dx + dy * dy);
            }
        };

        // --- 全局状态 ---
        const state = {
            lines: [],
            pois: [],
            metrics: {},
            
            // 视图相机
            camera: { x: 0, y: 0, zoom: 1 },
            
            // 交互状态
            mode: 'SELECT', // SELECT, DRAW, POI_*
            selectedIds: [], // Array of strings (line IDs or poi IDs)
            hoverId: null,
            
            // 动作状态
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            dragType: null, // 'PAN', 'BOX', 'MOVE', 'EDIT_NODE'
            activeHandle: null, // 'start' or 'end' for line editing
            currentLine: null, // For drawing
            boxSelectRect: null,
            
            history: [],
            historyIndex: -1,
            
            bgImage: null,
            canvas: null,
            ctx: null
        };

        // --- 历史记录系统 ---
        const historyManager = {
            push: () => {
                // 删除当前指针之后的历史
                if (state.historyIndex < state.history.length - 1) {
                    state.history = state.history.slice(0, state.historyIndex + 1);
                }
                // 深拷贝当前状态
                const snapshot = JSON.stringify({ lines: state.lines, pois: state.pois });
                state.history.push(snapshot);
                state.historyIndex++;
                if (state.history.length > 20) {
                    state.history.shift();
                    state.historyIndex--;
                }
            },
            undo: () => {
                if (state.historyIndex > 0) {
                    state.historyIndex--;
                    const snapshot = JSON.parse(state.history[state.historyIndex]);
                    state.lines = snapshot.lines;
                    state.pois = snapshot.pois;
                    state.selectedIds = [];
                    actions.recalculate();
                }
            }
        };

        // --- 坐标转换工具 ---
        const transform = {
            screenToWorld: (sx, sy) => ({
                x: (sx - state.camera.x) / state.camera.zoom,
                y: (sy - state.camera.y) / state.camera.zoom
            }),
            worldToScreen: (wx, wy) => ({
                x: wx * state.camera.zoom + state.camera.x,
                y: wy * state.camera.zoom + state.camera.y
            })
        };

        // --- 初始化 ---
        function init() {
            state.canvas = document.getElementById('mainCanvas');
            state.ctx = state.canvas.getContext('2d');
            
            // 初始数据
            state.lines = [
                { id: 'l1', x1: 100, y1: 400, x2: 900, y2: 400 }, // 主轴
                { id: 'l2', x1: 300, y1: 100, x2: 300, y2: 600 },
                { id: 'l3', x1: 700, y1: 200, x2: 700, y2: 500 }
            ];
            historyManager.push();
            
            resizeCanvas();
            bindEvents();
            actions.recalculate();
            
            // 渲染循环
            const loop = () => {
                render();
                requestAnimationFrame(loop);
            };
            loop();
        }

        function resizeCanvas() {
            const container = document.getElementById('canvasContainer');
            state.canvas.width = container.clientWidth;
            state.canvas.height = container.clientHeight;
            render();
        }

        function bindEvents() {
            const c = state.canvas;
            window.addEventListener('resize', resizeCanvas);
            
            c.addEventListener('mousedown', onMouseDown);
            window.addEventListener('mousemove', onMouseMove); // Window to handle drag outside
            window.addEventListener('mouseup', onMouseUp);
            c.addEventListener('wheel', onWheel, { passive: false });
            
            window.addEventListener('keydown', onKeyDown);
        }

        // --- 交互事件处理 ---
        
        function onMouseDown(e) {
            e.preventDefault();
            const { offsetX, offsetY, button, buttons } = e;
            const worldPos = transform.screenToWorld(offsetX, offsetY);
            
            // 中键 或 空格+左键 -> 平移
            if (button === 1 || (button === 0 && e.code === 'Space')) {
                state.isDragging = true;
                state.dragType = 'PAN';
                state.dragStart = { x: offsetX, y: offsetY };
                state.canvas.classList.add('cursor-panning');
                return;
            }

            if (button === 0) { // 左键
                state.dragStart = { x: worldPos.x, y: worldPos.y };
                state.isDragging = true;

                if (state.mode === 'DRAW') {
                    state.currentLine = { x1: worldPos.x, y1: worldPos.y, x2: worldPos.x, y2: worldPos.y };
                    return;
                }

                if (state.mode.startsWith('POI')) {
                    const type = state.mode.split('_')[1];
                    const poi = { id: `p_${Date.now()}`, x: worldPos.x, y: worldPos.y, type };
                    state.pois.push(poi);
                    historyManager.push();
                    state.mode = 'SELECT'; // 自动切回选择
                    updateUI();
                    actions.recalculate();
                    return;
                }

                if (state.mode === 'SELECT') {
                    // 1. 检查端点编辑 (仅在已选中且只有一条线时)
                    if (state.selectedIds.length === 1) {
                        const l = state.lines.find(l => l.id === state.selectedIds[0]);
                        if (l) {
                            const HIT_RADIUS = 10 / state.camera.zoom;
                            const d1 = Math.hypot(l.x1 - worldPos.x, l.l1 - worldPos.y); // Typo protection
                            if (Math.hypot(l.x1 - worldPos.x, l.y1 - worldPos.y) < HIT_RADIUS) {
                                state.dragType = 'EDIT_NODE';
                                state.activeHandle = 'start';
                                return;
                            }
                            if (Math.hypot(l.x2 - worldPos.x, l.y2 - worldPos.y) < HIT_RADIUS) {
                                state.dragType = 'EDIT_NODE';
                                state.activeHandle = 'end';
                                return;
                            }
                        }
                    }

                    // 2. 检查物体点击
                    const hit = hitTest(worldPos);
                    if (hit) {
                        state.dragType = 'MOVE';
                        if (e.ctrlKey || e.shiftKey) {
                            // 多选 toggle
                            if (state.selectedIds.includes(hit.id)) {
                                state.selectedIds = state.selectedIds.filter(id => id !== hit.id);
                            } else {
                                state.selectedIds.push(hit.id);
                            }
                        } else {
                            // 单选 (如果未选中)
                            if (!state.selectedIds.includes(hit.id)) {
                                state.selectedIds = [hit.id];
                            }
                        }
                    } else {
                        // 点击空白处
                        state.dragType = 'BOX';
                        state.boxSelectRect = { x: worldPos.x, y: worldPos.y, w: 0, h: 0 };
                        if (!e.ctrlKey && !e.shiftKey) state.selectedIds = [];
                    }
                }
            }
        }

        function onMouseMove(e) {
            const rect = state.canvas.getBoundingClientRect();
            const offsetX = e.clientX - rect.left;
            const offsetY = e.clientY - rect.top;
            const worldPos = transform.screenToWorld(offsetX, offsetY);

            // Hover effects
            if (!state.isDragging) {
                const hit = hitTest(worldPos);
                state.hoverId = hit ? hit.id : null;
                if (hit && state.metrics[hit.id]) {
                    showTooltip(e.clientX, e.clientY, hit.id, state.metrics[hit.id]);
                } else {
                    hideTooltip();
                }
                return;
            }

            // Handling Drags
            if (state.dragType === 'PAN') {
                const dx = offsetX - state.dragStart.x;
                const dy = offsetY - state.dragStart.y;
                state.camera.x += dx;
                state.camera.y += dy;
                state.dragStart = { x: offsetX, y: offsetY };
            } 
            else if (state.mode === 'DRAW' && state.currentLine) {
                state.currentLine.x2 = worldPos.x;
                state.currentLine.y2 = worldPos.y;
            }
            else if (state.dragType === 'MOVE') {
                const dx = worldPos.x - state.dragStart.x;
                const dy = worldPos.y - state.dragStart.y;
                
                state.selectedIds.forEach(id => {
                    const l = state.lines.find(x => x.id === id);
                    if (l) { l.x1 += dx; l.y1 += dy; l.x2 += dx; l.y2 += dy; }
                    const p = state.pois.find(x => x.id === id);
                    if (p) { p.x += dx; p.y += dy; }
                });
                state.dragStart = { x: worldPos.x, y: worldPos.y };
                actions.recalculate(); // Real-time update
            }
            else if (state.dragType === 'EDIT_NODE') {
                const l = state.lines.find(x => x.id === state.selectedIds[0]);
                if (l) {
                    if (state.activeHandle === 'start') { l.x1 = worldPos.x; l.y1 = worldPos.y; }
                    else { l.x2 = worldPos.x; l.y2 = worldPos.y; }
                    actions.recalculate();
                }
            }
            else if (state.dragType === 'BOX') {
                state.boxSelectRect.w = worldPos.x - state.boxSelectRect.x;
                state.boxSelectRect.h = worldPos.y - state.boxSelectRect.y;
                
                // Box Select Logic
                const bx = Math.min(state.boxSelectRect.x, state.boxSelectRect.x + state.boxSelectRect.w);
                const by = Math.min(state.boxSelectRect.y, state.boxSelectRect.y + state.boxSelectRect.h);
                const bw = Math.abs(state.boxSelectRect.w);
                const bh = Math.abs(state.boxSelectRect.h);
                
                const newSelection = [];
                state.lines.forEach(l => {
                    // Check if both points inside or midpoint inside
                    const mx = (l.x1 + l.x2)/2, my = (l.y1 + l.y2)/2;
                    if (mx >= bx && mx <= bx+bw && my >= by && my <= by+bh) newSelection.push(l.id);
                });
                state.pois.forEach(p => {
                    if (p.x >= bx && p.x <= bx+bw && p.y >= by && p.y <= by+bh) newSelection.push(p.id);
                });
                state.selectedIds = newSelection;
            }
        }

        function onMouseUp(e) {
            if (!state.isDragging) return;

            if (state.mode === 'DRAW' && state.currentLine) {
                const len = Math.hypot(state.currentLine.x2 - state.currentLine.x1, state.currentLine.y2 - state.currentLine.y1);
                if (len > 5) {
                    state.currentLine.id = `l_${Date.now()}`;
                    state.lines.push(state.currentLine);
                    historyManager.push();
                    actions.recalculate();
                }
                state.currentLine = null;
            }
            else if (['MOVE', 'EDIT_NODE'].includes(state.dragType)) {
                historyManager.push();
            }

            state.isDragging = false;
            state.dragType = null;
            state.activeHandle = null;
            state.boxSelectRect = null;
            state.canvas.classList.remove('cursor-panning');
        }

        function onWheel(e) {
            e.preventDefault();
            const zoomSensitivity = 0.001;
            const delta = -e.deltaY * zoomSensitivity;
            const zoomFactor = Math.pow(1.1, delta > 0 ? 1 : -1); // Smoother steps
            
            const rect = state.canvas.getBoundingClientRect();
            const mouseX = e.clientX - rect.left;
            const mouseY = e.clientY - rect.top;
            
            // Zoom towards mouse
            const worldMouse = transform.screenToWorld(mouseX, mouseY);
            
            let newZoom = state.camera.zoom * (delta > 0 ? 1.1 : 0.9);
            newZoom = Math.max(0.1, Math.min(10, newZoom));
            
            // Adjust camera position to keep mouse world position stationary
            state.camera.x = mouseX - worldMouse.x * newZoom;
            state.camera.y = mouseY - worldMouse.y * newZoom;
            state.camera.zoom = newZoom;
            
            document.getElementById('zoomLevel').innerText = Math.round(newZoom * 100) + '%';
        }

        function onKeyDown(e) {
            if (e.key === 'Delete' || e.key === 'Backspace') {
                actions.deleteSelection();
            }
            if (e.key === 'z' && (e.ctrlKey || e.metaKey)) {
                actions.undo();
            }
            // Shortcuts
            if (e.key === 'v') setMode('SELECT');
            if (e.key === 'p') setMode('DRAW');
        }

        // --- 逻辑辅助 ---

        function hitTest(pos) {
            const HIT_DIST = 8 / state.camera.zoom;
            // 1. Check POIs (on top)
            for (let i = state.pois.length - 1; i >= 0; i--) {
                const p = state.pois[i];
                if (Math.hypot(p.x - pos.x, p.y - pos.y) < HIT_DIST * 1.5) return p;
            }
            // 2. Check Lines
            for (let i = state.lines.length - 1; i >= 0; i--) {
                const l = state.lines[i];
                if (SyntaxEngine.distPointToSegment(pos, l) < HIT_DIST) return l;
            }
            return null;
        }

        // --- 渲染 ---

        function render() {
            const { ctx, canvas, camera, lines, pois, metrics, selectedIds } = state;
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // 1. 绘制背景图片 (World Space)
            ctx.save();
            ctx.translate(camera.x, camera.y);
            ctx.scale(camera.zoom, camera.zoom);
            
            if (state.bgImage) {
                // Assuming bg is at 0,0
                ctx.drawImage(state.bgImage, 0, 0); 
            } else {
                drawGrid(ctx, canvas, camera);
            }

            // 2. 绘制轴线
            lines.forEach(l => {
                const isSelected = selectedIds.includes(l.id);
                const isHover = state.hoverId === l.id;
                const m = metrics[l.id];
                
                ctx.lineCap = 'round';
                
                // Highlight Halo
                if (isSelected || isHover) {
                    ctx.beginPath();
                    ctx.moveTo(l.x1, l.y1);
                    ctx.lineTo(l.x2, l.y2);
                    ctx.lineWidth = 12 / camera.zoom;
                    ctx.strokeStyle = isSelected ? 'rgba(250, 204, 21, 0.5)' : 'rgba(255, 255, 255, 0.5)';
                    ctx.stroke();
                }

                // Main Line
                ctx.beginPath();
                ctx.moveTo(l.x1, l.y1);
                ctx.lineTo(l.x2, l.y2);
                ctx.lineWidth = 6 / camera.zoom;
                
                if (m) {
                    // Spectrum Color Mapping: (1-norm) * 240
                    // 1.0 -> 0 (Red), 0.0 -> 240 (Blue)
                    const hue = (1 - m.norm) * 240;
                    ctx.strokeStyle = `hsl(${hue}, 100%, 50%)`;
                } else {
                    ctx.strokeStyle = '#94a3b8';
                }
                ctx.stroke();

                // Draw Endpoints handles if selected
                if (isSelected && selectedIds.length === 1) {
                    drawHandle(ctx, l.x1, l.y1, camera.zoom);
                    drawHandle(ctx, l.x2, l.y2, camera.zoom);
                }
            });

            // 3. 绘制正在画的线
            if (state.currentLine) {
                const l = state.currentLine;
                ctx.beginPath();
                ctx.moveTo(l.x1, l.y1);
                ctx.lineTo(l.x2, l.y2);
                ctx.lineWidth = 2 / camera.zoom;
                ctx.strokeStyle = '#3b82f6';
                ctx.setLineDash([5 / camera.zoom, 5 / camera.zoom]);
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // 4. 绘制 POIs
            pois.forEach(p => {
                const isSelected = selectedIds.includes(p.id);
                const radius = (isSelected ? 10 : 8) / camera.zoom;
                
                ctx.beginPath();
                ctx.arc(p.x, p.y, radius, 0, Math.PI * 2);
                
                let color = '#64748b';
                let label = '';
                if (p.type === 'EMERGENCY') { color = '#ef4444'; label = 'E'; }
                else if (p.type === 'SURGERY') { color = '#3b82f6'; label = 'S'; }
                else if (p.type === 'ICU') { color = '#a855f7'; label = 'I'; }
                else if (p.type === 'WARD') { color = '#10b981'; label = 'W'; }

                ctx.fillStyle = color;
                ctx.fill();
                
                if (isSelected) {
                    ctx.lineWidth = 3 / camera.zoom;
                    ctx.strokeStyle = '#facc15'; // Yellow selection ring
                    ctx.stroke();
                } else {
                    ctx.lineWidth = 1.5 / camera.zoom;
                    ctx.strokeStyle = '#fff';
                    ctx.stroke();
                }
            });

            // 5. Box Selection Rect
            if (state.dragType === 'BOX' && state.boxSelectRect) {
                const r = state.boxSelectRect;
                ctx.fillStyle = 'rgba(59, 130, 246, 0.2)';
                ctx.strokeStyle = '#3b82f6';
                ctx.lineWidth = 1 / camera.zoom;
                ctx.fillRect(r.x, r.y, r.w, r.h);
                ctx.strokeRect(r.x, r.y, r.w, r.h);
            }

            ctx.restore();
        }

        function drawGrid(ctx, canvas, camera) {
            const step = 100; // World unit step
            
            // Adaptive Grid Opacity
            ctx.strokeStyle = '#e2e8f0';
            ctx.lineWidth = 1 / camera.zoom;
            
            // Viewport bounds in world space
            const left = -camera.x / camera.zoom;
            const top = -camera.y / camera.zoom;
            const right = left + canvas.width / camera.zoom;
            const bottom = top + canvas.height / camera.zoom;

            // Snap start to grid
            const startX = Math.floor(left / step) * step;
            const startY = Math.floor(top / step) * step;

            ctx.beginPath();
            for (let x = startX; x < right; x += step) {
                ctx.moveTo(x, top);
                ctx.lineTo(x, bottom);
            }
            for (let y = startY; y < bottom; y += step) {
                ctx.moveTo(left, y);
                ctx.lineTo(right, y);
            }
            ctx.stroke();
        }

        function drawHandle(ctx, x, y, zoom) {
            const size = 6 / zoom;
            ctx.fillStyle = '#fff';
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 1 / zoom;
            ctx.beginPath();
            ctx.rect(x - size/2, y - size/2, size, size);
            ctx.fill();
            ctx.stroke();
        }

        // --- UI & Actions ---

        const actions = {
            recalculate: () => {
                state.metrics = SyntaxEngine.calculate(state.lines);
                document.getElementById('objCount').innerText = `${state.lines.length} Lines`;
                updateDiagnostics();
            },
            deleteSelection: () => {
                if (state.selectedIds.length === 0) return;
                state.lines = state.lines.filter(l => !state.selectedIds.includes(l.id));
                state.pois = state.pois.filter(p => !state.selectedIds.includes(p.id));
                state.selectedIds = [];
                historyManager.push();
                actions.recalculate();
            },
            undo: historyManager.undo
        };

        function setMode(mode) {
            state.mode = mode;
            updateUI();
        }

        function updateUI() {
            // Update button styles
            const map = { 'SELECT': 'selectBtn', 'DRAW': 'drawBtn' };
            ['SELECT', 'DRAW'].forEach(m => {
                const el = document.getElementById(map[m]);
                if (m === state.mode) {
                    el.classList.add('bg-blue-600', 'text-white', 'ring-2', 'ring-blue-200');
                    el.classList.remove('bg-gray-100', 'hover:bg-gray-200');
                } else {
                    el.classList.remove('bg-blue-600', 'text-white', 'ring-2', 'ring-blue-200');
                    el.classList.add('bg-gray-100', 'hover:bg-gray-200');
                }
            });

            // Update POI buttons
            document.querySelectorAll('.poi-btn').forEach(b => {
                if (state.mode === 'POI_' + b.id.replace('Btn', '').toUpperCase()) {
                    b.classList.add('ring-2', 'ring-offset-1', 'bg-gray-50');
                } else {
                    b.classList.remove('ring-2', 'ring-offset-1', 'bg-gray-50');
                }
            });

            // Cursor
            if (state.mode === 'DRAW') state.canvas.className = 'cursor-draw';
            else if (state.mode === 'SELECT') state.canvas.className = 'cursor-select';
        }

        function handleFileUpload(e) {
            const file = e.target.files[0];
            if (file) {
                const reader = new FileReader();
                reader.onload = (event) => {
                    const img = new Image();
                    img.onload = () => {
                        state.bgImage = img;
                        // Auto center image
                        state.camera.x = (state.canvas.width - img.width)/2;
                        state.camera.y = (state.canvas.height - img.height)/2;
                        render();
                    };
                    img.src = event.target.result;
                };
                reader.readAsDataURL(file);
            }
        }

        function showTooltip(x, y, id, metric) {
            const el = document.getElementById('tooltip');
            el.classList.remove('hidden');
            el.style.left = x + 'px';
            el.style.top = y + 'px';
            document.getElementById('tooltipId').innerText = id;
            document.getElementById('tooltipGlobal').innerText = metric.global.toFixed(2);
            document.getElementById('tooltipLocal').innerText = metric.local.toFixed(2);
        }

        function hideTooltip() {
            document.getElementById('tooltip').classList.add('hidden');
        }

        function updateDiagnostics() {
            // Diagnosis Logic (Similar to previous, mapped to new metrics structure)
            const report = { foundE: false, foundS: false, foundI: false, depth: '-', intCount: 0, icuVal: 0 };
            
            // 1. Emergency
            const ePoi = state.pois.find(p => p.type === 'EMERGENCY');
            const sPoi = state.pois.find(p => p.type === 'SURGERY');
            
            if (ePoi && sPoi) {
                const l1 = SyntaxEngine.bfs('dummy', { get:()=>[] }).nodeCount; // Just helper access? No.
                // Re-find closest lines
                const findClosest = (p) => {
                    let minD = Infinity, res = null;
                    state.lines.forEach(l => {
                        const d = SyntaxEngine.distPointToSegment(p, l);
                        if (d < minD) { minD = d; res = l; }
                    });
                    return res;
                };
                
                const lStart = findClosest(ePoi);
                const lEnd = findClosest(sPoi);
                
                if (lStart && lEnd && state.metrics[lStart.id]) {
                    const d = state.metrics[lStart.id].depths.get(lEnd.id);
                    report.depth = d !== undefined ? d : '断连';
                    
                    const statusEl = document.getElementById('emergencyStatus');
                    if (d <= 3) {
                        statusEl.className = "mt-2 text-xs font-medium px-2 py-1 rounded w-fit bg-green-100 text-green-700";
                        statusEl.innerText = "优秀 (高效)";
                    } else if (d > 3) {
                        statusEl.className = "mt-2 text-xs font-medium px-2 py-1 rounded w-fit bg-red-100 text-red-700";
                        statusEl.innerText = "警告 (路径过长)";
                    } else {
                        statusEl.className = "mt-2 text-xs font-medium px-2 py-1 rounded w-fit bg-orange-100 text-orange-700";
                        statusEl.innerText = "路径不通";
                    }
                }
            }
            document.getElementById('emergencyDepth').innerText = report.depth;

            // 2. ICU
            const iPoi = state.pois.find(p => p.type === 'ICU');
            if (iPoi) {
                let minD = Infinity, res = null;
                state.lines.forEach(l => {
                    const d = SyntaxEngine.distPointToSegment(iPoi, l);
                    if (d < minD) { minD = d; res = l; }
                });
                if (res && state.metrics[res.id]) {
                    const val = state.metrics[res.id].local;
                    document.getElementById('privacyValue').innerText = val.toFixed(2);
                    const msgEl = document.getElementById('privacyMsg');
                    if (val > 0.8) { // Threshold
                         msgEl.innerText = "警告：位于高人流区";
                         msgEl.className = "text-xs mt-2 font-bold text-red-500";
                    } else {
                         msgEl.innerText = "位置良好 (安静)";
                         msgEl.className = "text-xs mt-2 text-green-500";
                    }
                }
            }

            // 3. Synergy
            const total = state.lines.length;
            const high = Object.values(state.metrics).filter(m => m.norm > 0.75).length;
            document.getElementById('highIntCount').innerText = high;
            document.getElementById('mainStreetStatus').innerText = high > 0 ? "已形成" : "未形成";
            document.getElementById('synergyBar').style.width = total > 0 ? `${(high/total)*100}%` : '0%';
        }

        window.onload = init;
    </script>
</body>
</html>
